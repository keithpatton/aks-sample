parameters:
- name: svcConnAzureRm
  type: string  
- name: tenants
  type: object  
- name: region
  type: string
- name: env
  type: string
- name: dependsOn  
  type: object
- name: rings
  type: object   
- name: imageBuild
  type: boolean
- name: imageBuildTag
  type: string

stages:
- stage: ${{ parameters.region }}_${{ parameters.env }}
  displayName: ${{ parameters.region }}_${{ parameters.env }}
  variables: 
    - template: ../../Common/Templates/variables/reg-env.yml 
      parameters:
        region: ${{ parameters.region }}
        env: ${{ parameters.env }}  
    - template: variables/reg-env.yml 
      parameters:
        region: ${{ parameters.region }}
        env: ${{ parameters.env }}  
        rings: ${{ parameters.rings }}  
  dependsOn: ${{ parameters.dependsOn }}
  pool:
    vmImage: ubuntu-latest 
  jobs:
  - deployment: Image
    displayName: Build and Push Image
    condition: and(succeeded(), eq('${{ parameters.imageBuild }}', 'true'))
    # for security reasons all environments must be provisioned by authorised person in advance
    environment: ${{ parameters.region }}_${{ parameters.env }}
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            clean: true   
          - task: Docker@2
            displayName: Build Image
            inputs:
              command: build
              repository: $(imageName)
              dockerfile: '$(Build.SourcesDirectory)/AksWorkloadIdentitySample.Api/Dockerfile'
              buildContext: '$(Build.SourcesDirectory)'
              tags: ${{ parameters.imageBuildTag }}
          - task: AzureCLI@2
            displayName: 'Push Image'
            inputs:
              azureSubscription: ${{ parameters.svcConnAzureRm}}
              scriptType: 'pscore'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr login --name $(acrName)
                docker tag $(imageName):${{ parameters.imageBuildTag }} $(acrName).azurecr.io/$(imageName):${{ parameters.imageBuildTag }}
                docker push $(acrName).azurecr.io/$(imageName):${{ parameters.imageBuildTag }}

  - deployment: Infrastructure    
    dependsOn: Image
    condition: in(dependencies.Image.result, 'Succeeded', 'Skipped')
    displayName: Ensure App Specific Infra
    environment: ${{ parameters.region }}_${{ parameters.env }}
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            clean: true   
          - template:  ../../Common/Templates/stageTenantsVarStep.yml        
            parameters:
              tenants: ${{ parameters.tenants }}
              region: ${{ parameters.region }}
              env: ${{ parameters.env }}                   
          - task: replacetokens@5
            displayName: 'Replace tokens with variables'
            inputs:
              targetFiles: |
                Devops/App/Terraform/**/variables.tf
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'warn'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true   
              verbosity: 'detailed'  
          - task: AzureCLI@2
            displayName: 'Ensure Terraform State Storage Account and Container'
            inputs:
              azureSubscription: ${{ parameters.svcConnAzureRm}}
              scriptType: 'pscore'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az group create --location $(location) --name $(tfStateResourceGroup)
                az storage account create -n $(tfStateStorageAccount) -g $(tfStateResourceGroup) -l $(location) --sku Standard_LRS --encryption-services blob
                az storage container create -n $(tfStateContainerName) --account-name $(tfStateStorageAccount) -g $(tfStateResourceGroup)          
          - task: AzureCLI@2
            displayName: 'Ensure Build Agent Access'
            continueOnError: true
            inputs:
              azureSubscription: $(svcConnAzureRm)
              addSpnToEnvironment: true
              scriptType: bash
              scriptLocation: 'inlineScript'
              inlineScript: |
                build_agent_ip=$(curl https://ipv4.icanhazip.com/)
                az sql server firewall-rule create -g $(rgName) --name "$(sqlFirewallRuleBuildAgentName)-pipeline" --server $(sqlServerName) --start-ip-address $build_agent_ip --end-ip-address $build_agent_ip     
          - task: TerraformTaskV3@3
            displayName: Terraform Init 
            inputs:
              provider: 'azurerm'
              backendServiceArm: ${{ parameters.svcConnAzureRm}}
              command: 'init'
              workingDirectory: '$(System.DefaultWorkingDirectory)/Devops/App/Terraform'
              backendAzureRmResourceGroupName: $(tfStateResourceGroup)
              backendAzureRmStorageAccountName: $(tfStateStorageAccount)
              backendAzureRmContainerName: $(tfStateContainerName)
              backendAzureRmKey: $(tfStateFileName)
          - task: TerraformTaskV3@3
            displayName: Terraform Apply
            inputs:
              provider: 'azurerm'
              environmentServiceNameAzureRM: ${{ parameters.svcConnAzureRm}}
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/Devops/App/Terraform'
              commandOptions: '--auto-approve'
              backendAzureRmResourceGroupName: $(tfStateResourceGroup)
              backendAzureRmStorageAccountName: $(tfStateStorageAccount)
              backendAzureRmContainerName: $(tfStateContainerName)
              backendAzureRmKey: $(tfStateFileName)   
          - task: TerraformTaskV3@3
            displayName: Terraform Output (e.g. Workload Identity ClientIds)
            inputs:
              provider: 'azurerm'
              environmentServiceNameAzureRM: ${{ parameters.svcConnAzureRm}}
              command: 'output'
              workingDirectory: '$(System.DefaultWorkingDirectory)/Devops/App/Terraform'
              backendAzureRmResourceGroupName: $(tfStateResourceGroup)
              backendAzureRmStorageAccountName: $(tfStateStorageAccount)
              backendAzureRmContainerName: $(tfStateContainerName)
              backendAzureRmKey: $(tfStateFileName)   
          - bash: |
              echo "AKS Identity Client Ids: $TF_OUT_AKS_IDENTITY_CLIENT_IDS"
              aksIdentityClientIds=$(echo $TF_OUT_AKS_IDENTITY_CLIENT_IDS)
              echo "##vso[task.setvariable variable=AksIdentityClientIds;isOutput=true]$aksIdentityClientIds"
            displayName: Set Terraform Output Variable                              
  - deployment: Deploy    
    variables:
    - name: aksIdentityClientIds
      value: $[ dependencies.Infrastructure.outputs['AksIdentityClientIds'] ]
    dependsOn: Infrastructure
    displayName: Deploy Application
    environment: ${{ parameters.region }}_${{ parameters.env }}
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            clean: true   
          - template:  ../../Common/Templates/stageTenantsVarStep.yml        
            parameters:
              tenants: ${{ parameters.tenants }}
              region: ${{ parameters.region }}
              env: ${{ parameters.env }}                                        
          - task: replacetokens@5
            displayName: 'Replace tokens with variables'
            inputs:
              targetFiles: |
                Devops/App/Helm/**/Chart.yaml
                Devops/App/Helm/**/values.yaml
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'warn'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true   
              verbosity: 'detailed'  
          - task: HelmDeploy@0
            displayName: 'Deploy $(appName)'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscription: ${{ parameters.svcConnAzureRm}}
              azureResourceGroup: $(rgName)
              kubernetesCluster: $(aksName)
              command: 'upgrade'
              chartType: 'FilePath'
              chartPath: '$(System.DefaultWorkingDirectory)/Devops/App/Helm/$(appName)'
              namespace: $(helmReleaseNamespace)
              releaseName: $(helmReleaseName)
              arguments: '--debug --atomic --reset-values'